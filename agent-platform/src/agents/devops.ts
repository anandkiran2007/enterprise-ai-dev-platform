
import { BaseAgent } from './base';
import { EventType } from '../core/events';
import { ProjectMemory } from '../core/memory';
import { IEventBus } from '../core/event_bus_adapters';
import { LLMService } from '../core/llm';
import * as fs from 'fs';
import * as path from 'path';

import { GitHubAdapter } from '../core/github_adapter';

export class DevOpsAgent extends BaseAgent {
    private github: GitHubAdapter;

    constructor(role: string, memory: ProjectMemory, eventBus: IEventBus, llm: LLMService) {
        super(role, memory, eventBus, llm);
        this.github = new GitHubAdapter();
    }

    initialize() {
        // Listen for QA passing, which signals we are ready to "deploy" (write to disk)
        this.eventBus.subscribe(EventType.UNIT_TESTS_PASSING, (event) => {
            console.log(`[DevOps Agent] Tests passed. Preparing for local deployment...`);
            this.deployLocally();
        });
    }

    protected getRelevantArtifacts(snapshot: any) {
        return {
            code_artifacts: snapshot.code_artifacts,
            living_documents: snapshot.living_documents
        };
    }

    async act(): Promise<boolean> {
        return false;
    }

    private async deployLocally() {
        this.memory.updatePhase('deployment');

        // Update status for UI
        this.memory.updateAgentContext(this.role, {
            currently_working_on: 'Deploying artifacts to output/ & Cloud...',
            next_tasks: ['finalize_release']
        });

        // Artificial delay for visualization
        await new Promise(resolve => setTimeout(resolve, 2000));

        const snapshot = this.memory.getSnapshot();
        const outputDir = path.join(process.cwd(), 'output', snapshot.project_id);

        console.log(`[DevOps Agent] Writing artifacts to ${outputDir}...`);

        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        // 1. Write Requirements
        if (snapshot.living_documents.requirements?.content) {
            fs.writeFileSync(
                path.join(outputDir, 'requirements.md'),
                snapshot.living_documents.requirements.content
            );
        }

        // 2. Write API Spec
        if (snapshot.living_documents.api_contracts?.openapi_spec) {
            fs.writeFileSync(
                path.join(outputDir, 'openapi.yaml'),
                snapshot.living_documents.api_contracts.openapi_spec
            );
        }

        // --- NEW: Cloud Sync ---
        const repoUrl = await this.github.createRepo(
            snapshot.project_name || 'project',
            snapshot.living_documents.requirements?.summary || 'AI Generated Project'
        );

        if (repoUrl) {
            this.memory.updateDocument('github_repo', {
                full_url: repoUrl,
                summary: 'GitHub Repository',
                version: '1.0.0',
                last_modified_by: 'DevOps Agent'
            });
            console.log(`[DevOps Agent] Linked GitHub Repo: ${repoUrl}`);
        }


        // 3. Write Frontend Code
        const frontend = snapshot.code_artifacts?.frontend;
        if (frontend?.generated_code) {
            const srcDir = path.join(outputDir, 'src');
            if (!fs.existsSync(srcDir)) fs.mkdirSync(srcDir);

            fs.writeFileSync(
                path.join(srcDir, 'App.tsx'),
                frontend.generated_code
            );
        }

        // 4. Generate README
        const readme = `# AI Generated Project\n\nGenerated by Enterprise AI Dev Platform.\n\n## Artifacts\n- requirements.md\n- openapi.yaml\n- src/App.tsx`;
        fs.writeFileSync(path.join(outputDir, 'README.md'), readme);

        console.log(`[DevOps Agent] Deployment complete. Check the 'output' folder.`);

        this.memory.updateAgentContext(this.role, {
            currently_working_on: 'idle',
            next_tasks: ['monitor_production']
        });
    }
}

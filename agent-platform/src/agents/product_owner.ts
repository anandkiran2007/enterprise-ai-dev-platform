
import { BaseAgent } from './base';
import { EventType } from '../core/events';

export class ProductOwnerAgent extends BaseAgent {

    initialize() {
        this.eventBus.subscribe(EventType.USER_IDEA_SUBMITTED, async (event) => {
            console.log(`[Product Owner] Received new idea from user: "${event.payload.idea}"`);
            await this.processUserIdea(event.payload.idea);
        });

        // Clear "Waiting for Approval" status when approved
        this.eventBus.subscribe(EventType.REQUIREMENTS_APPROVED, (event) => {
            console.log(`[Product Owner] Requirements Approved. Handing off to UX Designer.`);
            this.memory.updateAgentContext(this.role, {
                currently_working_on: 'idle', // Clear the blocking status
                next_tasks: ['monitor_progress']
            });
        });
    }

    protected getRelevantArtifacts(snapshot: any) {
        return {};
    }

    async act(): Promise<boolean> {
        return false;
    }

    async processUserIdea(idea: string) {
        this.log(`Analyzing idea: "${idea}"`);

        // Update Phase
        this.memory.updatePhase('requirements');

        // Update dashboard status
        this.memory.updateAgentContext(this.role, {
            currently_working_on: 'Analyzing user idea & generating requirements...',
            next_tasks: ['Emit requirements_ready']
        });

        // Use LLM to refine requirements
        const { AGENT_PROMPTS } = require('../core/prompts');
        const analysis = await this.llm.generateText([
            { role: 'system', content: AGENT_PROMPTS.product_owner },
            { role: 'user', content: `Analyze this idea: ${idea}\n\nOutput format:\nNAME: <ProjectName>\nREQUIREMENTS:\n<Requirements>` }
        ]);

        const projectNameMatch = analysis.match(/NAME:\s*(.*)/);
        const projectName = projectNameMatch ? projectNameMatch[1].trim() : 'AgentProject';
        const refinedRequirements = analysis.split('REQUIREMENTS:')[1] || analysis;

        this.memory.updateProjectName(projectName);
        this.log(`Project Initialized: ${projectName}`);

        // Create GitHub Repo immediately (if configured)
        const { GitHubAdapter } = require('../core/github_adapter');
        const adapter = new GitHubAdapter();
        if (adapter.isConfigured()) {
            await adapter.createRepo(projectName, `AI Generated Project: ${projectName}`);
            this.log(`GitHub Repository created for ${projectName}`);
        }

        this.log(`Requirements defined.`);

        this.memory.updateDocument('requirements', {
            version: '1.0',
            summary: refinedRequirements.split('\n')[1] || 'Requirements generated by AI', // heuristic
            full_url: 'storage://requirements_v1.md',
            last_modified_by: 'product_owner',
            content: refinedRequirements // Store the full content effectively
        });

        // Generate Master Project Plan
        this.log(`Generating Master Project Plan...`);
        const projectPlan = await this.llm.generateText([
            { role: 'system', content: AGENT_PROMPTS.product_owner + '\n\nTASK: Create a project plan.' },
            { role: 'user', content: `Create a plan for: ${idea}\n\nRequirements:\n${refinedRequirements}` }
        ]);

        // Write Plan to Disk
        const fs = require('fs');
        const path = require('path');
        const snapshot = this.memory.getSnapshot();
        const outputDir = path.join(process.cwd(), 'output', snapshot.project_id);
        if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true });

        fs.writeFileSync(path.join(outputDir, 'project_plan.md'), projectPlan);
        this.log(`Master Project Plan written to project_plan.md`);

        // Add to Living Documents for UI Visibility
        this.memory.updateDocument('project_plan', {
            version: '1.0',
            summary: 'Master Execution Plan',
            full_url: 'storage://project_plan.md',
            last_modified_by: 'product_owner',
            content: projectPlan
        });

        // Update dashboard status
        this.memory.updateAgentContext(this.role, {
            currently_working_on: 'Waiting for User Approval',
            next_tasks: ['Await REQUIREMENTS_APPROVED']
        });

        this.eventBus.emit(EventType.REQUIREMENTS_REVIEW_NEEDED, this.role, {
            summary: idea,
            requirements_doc: 'requirements'
        });
    }
}
